<h1 id="❖-gc란">❖ GC란?</h1>
<blockquote>
<p>C#에서 제공하는 자동으로 메모리를 관리해주는 컬렉터이다.</p>
</blockquote>
<ul>
<li>Heap을 순회하며 필요가 없어진 메모리를 삭제시킨다.</li>
</ul>
<p>예를들어</p>
<pre><code class="language-cs">
public void Array()
{
    int[] array= new int[5];
    for(int i = 0; i &lt; array.Length; i++)
    Console.Wirte(int[i]);
}
</code></pre>
<ul>
<li>라는 코드가 있다고 하면 배열은 메모리공간 중 Heap에 할당된다.</li>
<li>즉 이 함수가 실행되면 Heap에 배열이 할당되고 Stack에 array라는 지역변수가 할당된다.</li>
<li>그리고 끝나면 지역변수인 array는 삭제되고 Heap영역에 남아있는 더 이상 접근이 불가능한 배열가 생기게된다.</li>
<li>이를 가비지라고 하며 이걸 수집하는 것이 가비지 컬렉터이다.</li>
</ul>
<h1 id="❖-gc의-작동방식">❖ GC의 작동방식</h1>
<blockquote>
<ul>
<li>각 세그먼트가 연속된 메모리 범위인 힙 세그먼트를 할당한다.</li>
</ul>
</blockquote>
<ul>
<li><p>세그먼트 - 특정 길이를 가지는 연속적인 주소 공간을 나타내며 일반적으로 논리적인 부분을 나타낸다.</p>
</li>
<li><p>힙 세그먼트 - 동적으로 할당된 변수가 할당되는 영역이다.</p>
</li>
</ul>
<blockquote>
<ul>
<li>힙에 배치된 객체는 0,1,2 중 하나의 세대로 분류되는데 이 세대는 GC가 더 이상 참조하지 않는 관리형 객체에서 메모리를 해제하려고 시도하는 빈도를 결정한다. (세대가 낮을수록 더 많이 발생한다.)</li>
</ul>
</blockquote>
<ul>
<li><p>세대는 0, 1, 2로 3가지가 있는데 0세대부터 시작하여 가비지를 겪었지만 아직 메모리가 있다면 1세대, 1세대에서 가비지를 겪었지만 아직 메모리가 있다면 2세대가 되는 식이다.</p>
</li>
<li><p>이렇게 세대가 있는 이유는 세대가 높을 수록 가비지 컬렉터를 겪었다는 거고 이에 아직 메모리가 존재하는 1, 2세대같은 객체를 더 중요한 객체로 판단하기 위해서이다.</p>
</li>
<li><p>즉 GC는 쓰레기가 나올 가능성이 높은 세대를 우선적으로 수집하고 조건에 따라 다음 세대를 순차적으로 수집한다. </p>
</li>
<li><p>그 기준은 &quot;얼마나 GC가 발생했냐&quot; 이며 만약 여러차례 GC가 발생했어도 아직 메모리가 남아 있다면 - 계속 사용될 가능성이 높다고 판단하여 이를 후순위로 미루고 다른 영역을 먼저 수집한다.</p>
</li>
<li><p>세대가 높아질수록 GC의 빈도가 낮아져 단기 수명 객체는 항상 0세대를 유지한다.</p>
</li>
<li><p>만약 0세대를 대상으로 실행하고 그래도 메모리 확보가 불가능하다면 1세대, 그럼에도 안된다면 2세대 순으로 가며 </p>
</li>
<li><p>2세대까지 포함된 가비지 컬렉팅 수행 시에는 아예 프로세스를 일시정지하고 우선적으로 수행하기 때문에, 순간적인 프레임 드롭 등이 일어난다.</p>
</li>
</ul>
<blockquote>
<ul>
<li>GC는 프로그램이 실행되면 Heap에 초기 메모리를 미리 할당한다.</li>
</ul>
</blockquote>
<p><strong>✦ 초기 힙 세그먼트 예약한다.</strong></p>
<ul>
<li>GC는 일정크기의 메모리를 예약한다.</li>
<li>이 메모리는 OS로 부터 요청되지만 아직 사용되지는 않는다.</li>
</ul>
<p><strong>✦ 일부 메모리를 커밋한다.</strong></p>
<ul>
<li>예약된 메모리를 일부 실제 사용하기 위해 커밋한다.</li>
<li>커밋된 메모리는 즉시 사용이 가능하다.</li>
<li>필요한 만큼의 메모리만 커밋하고 나머지는 추후 필요하면 커밋한다.</li>
</ul>
<p><strong>✦ 성능상의 이유로 미리 할당한다.</strong></p>
<ul>
<li>메모리를 미리 예약하면 연속된 메모리 블록을 확보할 수 있다.</li>
<li>연속된 메모리는 캐시 효율성 증가 및 성능 향상을 기대할 수 있다.</li>
<li>앱이 동작하면서 객체를 생성해도 메모리 단편화 문제를 줄일 수 있다.</li>
</ul>
<p><strong>(메모리가 나눠져 있다면 모으는 과정이 필요하지만 연속된 메모리는 한번에 가져오기가 가능하기 때문)</strong></p>
<p><em>메모리 단편화 - 기억장치의 빈 공간 또는 자료가 여러조각으로 나뉘는 현상</em></p>
<h2 id="✤-객체-크기에-따른-세대">✤ 객체 크기에 따른 세대</h2>
<p>GC는 객체를 크기에 따라 다르게 분류한다.
85,000바이트 보다 작으면 SOH(Small Of Heap), 크거나 같으면 LOH(Large Of Heap)으로 구분된다.</p>
<ul>
<li>SOH는 0세대 부터시작되며, LOH는 바로 2세대로 등록된다.</li>
<li>즉 크기가 큰 객체를 중요객체라고 GC는 판단하는 것이다.</li>
<li>가비지 컬렉팅 후 SOH들은 메모리 단편화를 없애기위해 재배치된다.</li>
<li>하지만 LOH의 경우 옮기는 과정에서 오버헤드가 크게 발생하기 때문에 가비지 컬렉팅 후 이동하지 않는다.</li>
</ul>
<h1 id="❖-불필요한-가비지-생성">❖ 불필요한 가비지 생성</h1>
<h2 id="✤-리스트와-배열">✤ 리스트와 배열</h2>
<p>앞서 말했던 대로 GC는 연속적인 메모리에 대해 효율성이 좋다.</p>
<ul>
<li>List는 불규칙적인데 반면, 배열은 연속적이고 규칙적이기 때문에 배열이 효율이 좋다.
이는 List를 보면 알 수 있는데</li>
</ul>
<p>List 는</p>
<ul>
<li>Add(), Remove()로 추가, 삭제가 가능하다고 List의 갯수만큼만 크기를 가지는 것이 아니다.</li>
<li>내부적으로는 배열처럼 고정된 크기를 가지고 있으며 그 크기를 넘어선 추가 요청 시</li>
<li>원래 있던 List의 크기 보다 더 큰 List를 생성한 뒤 그 안에 값을 집어 넣는 방식이다.</li>
<li>그러면 원래 있던 List는 더 이상 접근이 불가능 해진다. 즉 가비지가 된다.</li>
<li>List를 반복하여 추가하는 작업은 가비지의 생성과 많은 데이터의 복사를 동시에 유발하므로
List를 굳이 쓸 이유가 없다면 List보다는 배열을 쓰는 것이 성능적으로 더 좋은 선택이다.</li>
</ul>
<h2 id="✤-많은-loh로-생기는-문제점">✤ 많은 LOH로 생기는 문제점</h2>
<p>LOH라는 큰 오브젝트를 많이 생성하게 되면 2세대가 힙 영역에 가득하게 되어</p>
<ul>
<li>가비지 컬렉팅의 효율이 떨어지고 메모리 단편화가 발생할 수 있다.</li>
<li>그래서 우리는 많은 큰 오브젝트 클래스의 인스턴스 생성에는 주의해야한다. </li>
</ul>