<h1 id="❖-인터페이스란">❖ 인터페이스란?</h1>
<blockquote>
<p>강제로 기능을 구현하도록하는 것이다.</p>
</blockquote>
<ul>
<li><p>우리가 기능을 만들다 보면 놓치는 기능들이 생긴다.
하지만 이러면 기능이 있어야할 클래스에 없는 문제 때문에 오류가 발생할 수도 있다.</p>
</li>
<li><p>그래서 인터페이스를 사용하여 일종의 약속처럼 무조건 구현해야 한다. 라고 선언하는 것이다.</p>
</li>
<li><p>C#은 다중상속의 위험성 때문에 다중상속이 불가능하다.
만약 상속받은 두 클래스가 같은 이름의 기능이 있다면 무엇을 사용하지 선택할 수 없다.</p>
</li>
<li><p>또한 그 위의 상위객체를 두 클래스가 상속 받았을 때에는 이 처럼 중복된 데이터와 기능들이 늘어나 이걸 구분하는 것이 위험 하기 때문에 다중상속이 불가능하다. 이걸 죽음의 다이아몬드라고 한다.</p>
</li>
<li><p>이때 대채제로 사용이 가능한 것이 인터페이스이다.</p>
</li>
<li><p>인터페이스를 만들때는 앞에 I를 붙이는 것이 국룰처럼 쓰인다. (인터페이스인지 알기 쉽게)</p>
</li>
<li><p>인터페이스는 상속구조와 비슷하게 되어있어 인터페이스를 상속받은 객체가 구현한 인터페이스를 가져올 수가 있는데 그럼 이 인터페이스를 가진 모든객체를 스캔해 각자의 기능을 실행하는 것도 가능하다.(사실 상속과는 다른 개념이다.)</p>
</li>
<li><p>인터페이스는 구현은 하지않는다. 필드를 가지고 있지도 않다. 그저 꼭 구현하라는 기능만을 제시하는 것이다.</p>
</li>
</ul>
<p>인터페이스의 예시이다.</p>
<pre><code class="language-cs">internal class Player : Entity, IMovement
{
    public void Move(int x, int y)
    {
        throw new NotImplementedException();
    }

    public void Turn()
    {
        throw new NotImplementedException();
    }
}

public interface IMovement
{
    void Move(int x, int y);
    void Turn();
}

public class Entity
{

}</code></pre>
<p>Player는 부모클래스를 상속받고도 인터페이스를 상속받아 무조건 필요한 기능을 구현해 넣을 수있다.</p>
<ul>
<li>이렇게 상속을 하면 Player는 반드시 움직이는 기능이 있다. 라는 것이 된다.</li>
<li>즉 인터페이스는 이 기능이 상속받은 객체에 무조건 존재한다. 라는 의미가 되는 것이다.</li>
</ul>
<pre><code class="language-cs">public void EntityMove(IMovement m)
{
    m.Move(1,1);
}</code></pre>
<ul>
<li>이럼 인터페이스를 포함한 객체들의 인터페이스 기능을 각각 사용할 수 있다.(상속이기 때문)</li>
</ul>
<h1 id="❖-인터페이스와-추상클래스">❖ 인터페이스와 추상클래스</h1>
<blockquote>
<p>둘 모두 무조건 구현해라 라는 공통점이 있어 똑같다고 생각할 수 있지만 상황이 다르다.</p>
</blockquote>
<ul>
<li>추상클래스는 변수 선언과 함수의 구현까지도 가능하지만 다중상속이 불가능하고</li>
<li>인터페이스는 변수 선언과 함수의 구현이 불가능하지만 다중상속이 가능하다.</li>
</ul>
<h3 id="✧-a-is-b-관계">✧ A is B 관계</h3>
<blockquote>
<p><del>는 ~</del>이다 라는 관계이다.</p>
</blockquote>
<p>상속 관계에서는 추상클래스로 구현하여 상속에 대한 이점들을 이용할 수 있다.</p>
<ul>
<li>추상클래스는 상속하면 바로 만들라고 지시하여 바로 구현이 가능하지만
인터페이스는 따로 인터페이스를 추가해 주어야만 구현하라고 뜨기 때문에 일을 하나 더하게 된다.</li>
</ul>
<h3 id="✧-a-can-b-관계">✧ A can B 관계</h3>
<blockquote>
<p><del>는 ~</del>할 수 있다 라는 관계이다.</p>
</blockquote>
<ul>
<li><p>이 행동을 할 수 있는 경우에 적합하다. (예) 문은 열수 있다. 데미지를 줄수 있다.)
이런한 관계 때문에 인터페이스는 보통 able로 끝난다. (IDamageable)</p>
</li>
<li><p>클래스는 인터페이스에 정의된 함수들을 클래스의 목적에 맞는 기능을 구현한다.</p>
</li>
</ul>
<p>추상클래스는 설계도의 개념이다.</p>
<ul>
<li>추상클래스를 상속받는 객체는 추상클래스의 기능을 모두 필요로 해야할때와 공통된 기능을 미리 구현해두고 싶을 때에 적합하다.</li>
<li>즉 추상클래스는 정확히 상속의 개념이다.</li>
</ul>
<p>인터페이스는 계약서같은 개념이다.</p>
<ul>
<li>너는 무조건 구현해야 한다. 라는 약속을 하는것이다.</li>
<li>즉 얘는 이런기능이 있다. 라고 선언하는 것이다.</li>
</ul>
<h3 id="✧-정리">✧ 정리</h3>
<ul>
<li><p>예를 들어 상자와 문이 있다. 둘다 문을 여는 기능이 있어야한다.
그러면 둘다 문을 열수 있는 기능을 가진 추상 클래스를 상속받아 사용한다고 쳐보자.
좋은 사용 방법이라고 생각한다.</p>
</li>
<li><p>하지만 상자는 이 기능만이 필요한 것이 아니다. 아이템이 드롭되는 기능도 필요로 한다.
이 때 부모 클래스에서 아이템 드롭기능을 만들면 해결은 가능하나. 문도 아이템 드롭이 된다.
설계가 어긋난다는 것이다.</p>
</li>
<li><p>즉 상자에서 따로 기능을 구현해야하는데 인터페이스를 안쓰고도 구현이 가능하지만 한번 생각해보자.
아이템이 드롭되는기능이 과연 이 객체에서만 쓰일까? 아니다.</p>
</li>
<li><p>보통 게임에서는 몬스터, 기믹보상, 필드 이벤트 등 많은 아이템드롭이 존재한다.
그러면 아이템 드롭을 각각 마다 다 구현해 주면 되는거 아닌가? 라고한다면</p>
</li>
<li><p>전부 다 같은 이름으로 구현될 보장이 없어 찾기가 힘들고 만약 보장이 된다고 하더라도 그 마다의 객체에서 꺼내와야하는 번거로움이 생긴다.</p>
</li>
<li><p>하지만 여기서 인터페이스로 아이템 드롭기능을 구현한다고 해보자.
그럼 우리는 어떠한 아이템 드롭 기능이더라도 IDropable이라는 인터페이스의 Drop함수만을 호출하면 된다.</p>
</li>
<li><p>즉 이런식으로 같은기능을 같은 부모클래스를 상속받지 않은 각각의 객체들이 많이 사용되어야 할 경우에는 인터페이스가 적절하다고 볼 수 있다.</p>
</li>
<li><p>그리고 이런 구성을 하게되면 객체의 기능을 실행못하고 목적에 맞는 기능만을 실행할 수 있도록 제한한다. 즉 인터페이스는 제약을 위해서 사용하기도 한다.</p>
</li>
</ul>
<p>(예를 들어 데미지를 주는기능만 넘겨주고, 움직이는 기능만을 인터페이스로 넘겨주는 식이다.)</p>