<h1 id="문제">문제</h1>
<p>정수 n, left, right가 주어집니다. 다음 과정을 거쳐서 1차원 배열을 만들고자 합니다.</p>
<p>n행 n열 크기의 비어있는 2차원 배열을 만듭니다.
i = 1, 2, 3, ..., n에 대해서, 다음 과정을 반복합니다.
1행 1열부터 i행 i열까지의 영역 내의 모든 빈 칸을 숫자 i로 채웁니다.
1행, 2행, ..., n행을 잘라내어 모두 이어붙인 새로운 1차원 배열을 만듭니다.
새로운 1차원 배열을 arr이라 할 때, arr[left], arr[left+1], ..., arr[right]만 남기고 나머지는 지웁니다.
정수 n, left, right가 매개변수로 주어집니다. 주어진 과정대로 만들어진 1차원 배열을 return 하도록 solution 함수를 완성해주세요.</p>
<h1 id="풀이">풀이</h1>
<ul>
<li>문제에 적힌 그대로 배열을 만든다면 메모리가 터진다.</li>
<li>그래서 다른 방법은 기본적은 계산으로 row와 col을 구해서 하는 방식이 있다.</li>
</ul>
<pre><code class="language-cs">private int[] ArrayCut(int n, long left, long right)
{
    int size = (int)(right - left + 1); // 결과 Size는 정해져 있음
    int[] result = new int[size];

    for(long i = left; i &lt;= right; i++)
    {
        long row = i / n;   // 한 행에 n개씩 있으니
        long col = i % n;   // 그 줄에서 몇 번째 열인지는 나눈 나머지로 알 수 있음
                            // n이 3이라면 0,1,2 반복

        // 현재 인덱스 i가 배열에서 어디 들어가는지를 계산후
        // row와 col 값중 더 높은 값 넣기
        result[i-left] = (int)(Math.Max(row,col) + 1);
    }

    return result;
}</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/hsd0604/post/53dff62b-1d51-41b8-802b-c1dbf1eb608e/image.png" /></p>
<ul>
<li>이런식으로 2차원 배열을 사용하지 않고도 행, 열 계산을 하여 구할 수 있다.</li>
</ul>