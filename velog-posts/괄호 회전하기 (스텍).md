<h1 id="문제">문제</h1>
<p>다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 정의합니다.</p>
<p>(), [], {} 는 모두 올바른 괄호 문자열입니다.
만약 A가 올바른 괄호 문자열이라면, (A), [A], {A} 도 올바른 괄호 문자열입니다. 예를 들어, [] 가 올바른 괄호 문자열이므로, ([]) 도 올바른 괄호 문자열입니다.
만약 A, B가 올바른 괄호 문자열이라면, AB 도 올바른 괄호 문자열입니다. 예를 들어, {} 와 ([]) 가 올바른 괄호 문자열이므로, {}([]) 도 올바른 괄호 문자열입니다.
대괄호, 중괄호, 그리고 소괄호로 이루어진 문자열 s가 매개변수로 주어집니다. 이 s를 왼쪽으로 x (0 ≤ x &lt; (s의 길이)) 칸만큼 회전시켰을 때 s가 올바른 괄호 문자열이 되게 하는 x의 개수를 return 하도록 solution 함수를 완성해주세요.</p>
<h1 id="풀이">풀이</h1>
<blockquote>
<p>Stack으로 풀이를 진행함.</p>
</blockquote>
<pre><code class="language-cs">public int Parentheses(string s)
{
    int answer = 0;
    int len = s.Length;
    Stack&lt;char&gt; stack = new Stack&lt;char&gt;();

    for(int i = 0; i &lt; len; i++)
    {
        stack.Clear();              // 실행마다 전의 stack에 남아있던 문자들을 삭제

        // s의 앞에서 i번째 문자만큼을 자르고 
        // +s의 0번 부터 i번째 까지의 자른 문자열을 다시 뒤에 붙혀 회전
        string rot = s.Substring(i) + s.Substring(0, i);
        bool isValid = true; // 검사할 Bool 변수

        foreach (char c in rot)
        {
            if(c == '(' || c== '{' || c == '[') // 만약 괄호의 시작이라면 stack에 넣음
                stack.Push(c);
            else // 아니라면
            {
                if (stack.Count == 0) // 스텍에 아무것도 없다면 false로 바꾸고 나감
                {
                    isValid = false;
                    break;
                };

                char top = stack.Pop(); // 스텍에 있다면 스텍에 있는 값을 받아옴(괄호 시작 값)

                // 모든 괄호의 맞지않는 경우의 수를 구해서 맞지않다면 false로 바꾸고 나감
                if (top != '(' &amp;&amp; c == ')' ||
                   top != '{' &amp;&amp; c == '}' ||
                   top != '[' &amp;&amp; c == ']')
                {
                    isValid = false;
                    break;
                }
            }
        }

        if (isValid &amp;&amp; stack.Count == 0) // 만약 틀린조건이라 걸러지지도 않았고 stack에 남은 것도 없다면
            answer++;                   // answer에 1을 추가함
    }                

    return answer;  // 올바른 괄호의 수를 반환함.
}</code></pre>
<p>괄호 판단을 문자열을 회전시키면서 하는게 의외로 좀 어지러웠던 것 같기도하다
문자열을 회전시키는 방법은 더 효율적인게 있는지 확인해 봐야겠다.
(Queue 슬라이딩 윈도우 등)</p>
<p>이 문제 자체가 시간복잡도가 O(N²)이 나오는데 어쩔 수 없는 것 같다.</p>