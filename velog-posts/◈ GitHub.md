<h1 id="❖-github이란">❖ GitHub이란?</h1>
<blockquote>
<p>변경 전과 변경 후의 버전관리를 해주고 업로드, 다운로드도 지원하는 유용한 도구이다.</p>
</blockquote>
<ul>
<li><p>개발자에게 저장은 숨을 쉬는 것과 같다. 그래서 이러한 저장소는 개발자에게 꼭 필요한 도구이다.</p>
</li>
<li><p>버전관리는 디버깅 측면에서도 도움이 많이된다.</p>
</li>
</ul>
<h1 id="❖-기능">❖ 기능</h1>
<h3 id="✧-자동-트래킹">✧ 자동 트래킹</h3>
<ul>
<li>저장소(리포지토리)를 만들고 파일을 지정 후 파일이 변경되면 Git에서는 - 이를 인식하여 변경내용을 말해주고 Commit을 할 수 있게 해준다.</li>
</ul>
<h3 id="✧-commit">✧ Commit</h3>
<ul>
<li>변경사항들을 저장을 하는 것이다.</li>
<li>설명을 작성 할 수도 있다.</li>
</ul>
<h3 id="✧-clone">✧ Clone</h3>
<ul>
<li>자신이 가지고 있는 리포지토리나 GitHub의 URL을 이용해서</li>
<li>그 리포지토리의 복사본을 만들 수 있다.</li>
</ul>
<h3 id="✧-fetch">✧ fetch</h3>
<ul>
<li>자신이 가지고 있는 버전이 더 낮은 버전일 경우</li>
<li>변경된 내용을 확인하기위해 새로고침하는 기능이다.</li>
</ul>
<h3 id="✧-원격-저장소에-저장-push">✧ 원격 저장소에 저장 (Push)</h3>
<ul>
<li>Git을 쓰는 이유이다.</li>
<li>사이트로 볼 수 있고 버전관리가 가능한 Git원격 저장소에 저장된다.</li>
<li>협업으로 공유하기도 쉽다.</li>
</ul>
<h3 id="✧-pull">✧ Pull</h3>
<ul>
<li>다른사람이 올려둔 다음버전을 내가 가져올 수 있다,</li>
<li>즉 변경사항을 내가 쉽게 가져올 수 있다는 것이다.</li>
</ul>
<h3 id="✧-checkout">✧ CheckOut</h3>
<ul>
<li>History에서 과거버전으로 잠깐 가볼 수 있는 기능이다.</li>
<li>단 반드시 다시 과거버전에서 최신버전으로 바꿔야한다.</li>
</ul>
<h1 id="❖-git의-동작">❖ Git의 동작</h1>
<ul>
<li>컴퓨터의 저장소는 Local 저장소 이고 </li>
<li>GitHub의 저장소는 리모트(원격) 저장소 라고 한다.</li>
</ul>
<p>Local에서 작업을 하면 자동으로 수정내용을 추적하고 Commit을 하면
그 내용을 원격 저장소에 올릴 수 있고 버전별로 나누어 내려 받을 수도 있다.
<img alt="" src="https://velog.velcdn.com/images/hsd0604/post/c395b4ad-3491-41c0-b647-b0b9a73b4057/image.jpg" /></p>
<ul>
<li><p>Commit과정에서 수정한,제작한 내용이 무엇인지 정확히 알 수 있는 이름으로 적어주어야 한다.</p>
</li>
<li><p>그래서 팀 협업시 수정은 [Fix]를, 제작은 [Make] 앞에 붙이자 같은 것을 정하고 가는 것이 좋다.
<img alt="" src="https://velog.velcdn.com/images/hsd0604/post/7249398a-b74d-463e-8ea6-1dff8615811d/image.png" /></p>
</li>
<li><p>Change쪽에서는 변경사항 확인과 Commit을 할 수 있고</p>
</li>
<li><p>History쪽에서는 프로젝트의 흐름을 확인 할 수 있다.</p>
</li>
</ul>
<h2 id="✤-충돌">✤ 충돌</h2>
<ul>
<li><p>최신버전이 아닌 이전버전을 작업하고 최신버전으로 업데이트를 하게되면
충돌이 일어난다.</p>
</li>
<li><p>예를 들어 A에서 변수를 만들고 올렸다.</p>
</li>
<li><p>그 후 B가 A의 버전을 pull 하지않고 변수를 만들고 올렸는데</p>
</li>
<li><p>A와 B의 변수가 같아서 Git은 판단하지못해서 일단 둘 다 넣게된다.</p>
</li>
<li><p>그러면 자연스럽게 코드오류로 이어지고 Git에서 이를 판단해서 충돌이 발생했다고 알려준다.</p>
</li>
</ul>
<p><strong>✧ 그래서 항상 최신버전 인지부터 확인 후 작업하도록 하자.</strong></p>
<ul>
<li><p>push를 하면 (원격 저장소에 저장되면) 취소가 불가능하다.</p>
</li>
<li><p>push했다는 건 공유 했다는 것이기에 공유받은 팀원이 작업하고 있다면 프로젝트에도 영향을 끼친다.</p>
</li>
<li><p>그래서 원칙상 삭제가 불가능한게 맞다.(억지 삭제는 가능하긴하나... 하지마라)</p>
</li>
</ul>
<p>*<em>✧ 만약 고쳐야할 부분이 있다면? *</em></p>
<ul>
<li>다시 고친후 [Fix]같은 키워드를 달아서 고쳤다는 수정버전을 올려주어야 한다.</li>
</ul>
<h2 id="✤-코테-연동">✤ 코테 연동</h2>
<ul>
<li><p>Git과 코테를 연동하는 것이 가능하다.</p>
</li>
<li><p>확장프로그램을 다운받아 세팅해주면 리포지토리를 생성할 수 있다.</p>
</li>
<li><p>이제 코테에서 문제를 풀고 체크가 나올때 까지 기다리면 자동으로 생성한 리포지토리에 Commit된다. 엄청 편하다.</p>
</li>
</ul>
<h1 id="유니티-프로젝트-commit">유니티 프로젝트 Commit</h1>
<ul>
<li><p>유니티 프로젝트의 크기는 100mb가 넘지만 commit의 제한 용량은 딱 100mb이다.</p>
</li>
<li><p>유니티 프로젝트를 올리기 위해서는 gitignore이라는 파일을 넣어 유니티 프로젝트의 용량 대부분을 차지하는 Library같은 파일들을 무시 시켜줘야한다.</p>
</li>
<li><p>그럼 용량이 아주 많이 줄어들게 되고 유니티프로젝트를 쉽게 올릴 수 있다.</p>
</li>
<li><p>모델링같은 리소스들은 따로 관리하는 것이 좋겠다.</p>
</li>
</ul>